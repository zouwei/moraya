# v0.19.0 — 渲染管线优化（Rendering Pipeline v2）

## 概述

针对编辑器与 Typora 的流畅度差距，从渲染管线层面进行系统性优化。核心发现：Moraya 运行在 WKWebView (JavaScriptCore) 上，JS 引擎性能弱于 Electron (V8)，加上 ProseMirror ~29 个插件的同步 apply() 开销，导致每次按键延迟偏高。

## 优化分三个阶段

### Phase 1: 惰性序列化（已完成）

消除 visual 模式下每次按键的全文 markdown 序列化，改为按需序列化。

**改动摘要：**
- `setup.ts`: 新增 `createDirtyTrackPlugin`（O(1) dirty 标记），保留 `createLazyChangePlugin`（500ms debounce，仅 split 模式使用）
- `Editor.svelte`: `onDocChanged` 轻量通知替代 `onChange`，新增 `getFullMarkdown()` 按需序列化
- `editor-store.ts`: 新增 `markDirty()`（仅 false→true 触发通知）和 `scheduleWordCountFromText()`
- `+page.svelte`: `getCurrentContent()` 按需序列化，save/export/AI/guardUnsaved 全部走按需路径
- `AIChatPanel.svelte`: `getDocumentContent` 回调替代静态 prop

### Phase 2: 插件合并与短路优化（已完成）

将 ~29 个插件减少到 ~24 个，并为常见按键添加短路逻辑。

### Phase 3: 去除 Milkdown 抽象层（已完成）

完全移除 Milkdown 抽象层（12 个 `@milkdown/*` 包），改为直接使用 ProseMirror API + prosemirror-markdown + markdown-it。

**核心收益：**
- Bundle 减小（去除 Milkdown core/transformer/utils + remark 生态链）
- 初始化更快（无 Milkdown builder 流程）
- 完全控制渲染管线，消除 `editor.action((ctx) => ctx.get(editorViewCtx))` 间接访问开销（Editor.svelte 中原有 ~30+ 处）
- markdown-it 直接解析比 remark→MDAST→PM 管线更轻量

**改动摘要：**

| 子阶段 | 内容 |
|--------|------|
| 3A | 安装 15 个 prosemirror-* + markdown-it 依赖；新建 `schema.ts`（23 nodes + 5 marks）和 `markdown.ts`（markdown-it 解析器 + MarkdownSerializer） |
| 3B | 新建 `commands.ts`（所有编辑器命令）；6 个插件文件去除 `$prose`/`$view`/`$nodeSchema` 包装 |
| 3C | 完全重写 `setup.ts`：`MorayaEditor` 接口 + 直接 `EditorView` 创建 |
| 3D | 迁移 `Editor.svelte`：~30 处 `editor.action()` → 直接 `editor.view` 访问 |
| 3E | 迁移 `+page.svelte`：`callCommand()` → `commands.ts` 直接调用 |
| 3F | 移除 12 个 `@milkdown/*` 包 + `remark-definition-list`；删除 `empty-doc-focus.ts`；更新 CLAUDE.md |

**新建文件：**

| 文件 | 说明 |
|------|------|
| `src/lib/editor/schema.ts` | 统一 ProseMirror Schema，23 种节点 + 5 种 mark，从 Milkdown 源码精确提取 |
| `src/lib/editor/markdown.ts` | markdown-it 解析器（含 deflist/texmath/table/strikethrough 插件）+ ProseMirror MarkdownSerializer |
| `src/lib/editor/commands.ts` | 所有编辑器命令（标准 ProseMirror `(state, dispatch?, view?) => boolean` 签名） |

**关键抽象替换映射：**

| Milkdown 抽象 | ProseMirror 等价 |
|---|---|
| `$prose(() => new Plugin(...))` | 直接 `new Plugin(...)` / `export function createXxxPlugin(): Plugin` |
| `$view(schema.node, factory)` | `nodeViews: { code_block: factory }` |
| `$nodeSchema('name', () => spec)` | 写入 `schema.ts` |
| `$remark('name', () => plugin)` | `markdown-it-deflist` 替代 |
| `Editor.make().config().use().create()` | `new EditorView(root, { state, nodeViews })` |
| `editor.action((ctx) => ctx.get(editorViewCtx))` | 直接 `editor.view` |
| `callCommand(cmd.key, payload)` | 直接 `cmd(state, dispatch, view)` |
| `getMarkdown(editor)` / `ctx.get(serializerCtx)` | `editor.getMarkdown()` / `serializeMarkdown(doc)` |
| `ctx.get(parserCtx)(md)` | `parseMarkdown(md)` |

**移除的依赖（13 个）：**
`@milkdown/core`, `@milkdown/ctx`, `@milkdown/plugin-clipboard`, `@milkdown/plugin-cursor`, `@milkdown/plugin-history`, `@milkdown/plugin-math`, `@milkdown/plugin-tooltip`, `@milkdown/preset-commonmark`, `@milkdown/preset-gfm`, `@milkdown/prose`, `@milkdown/transformer`, `@milkdown/utils`, `remark-definition-list`

## Phase 2 功能详情

### F1: 合并 5 个 prop 类插件为 1 个

**问题**：`setup.ts` 中定义了 5 个仅使用 `props` 的独立 Plugin，每个都参与事务 apply() 循环。

**5 个待合并插件：**

| 插件 | props 类型 | 功能 |
|------|-----------|------|
| `pasteLanguageFixPlugin` | `transformPastedHTML` | 粘贴时修复 code 块语言属性 |
| `imageClickPlugin` | `handleClickOn` | 图片点击→文本光标（防止蓝色选中） |
| `selectAllFixPlugin` | `handleKeyDown` | macOS Cmd+A 修复 |
| `caretFixPlugin` | `decorations` | WKWebView 空段落假光标 |
| `scrollAfterPastePlugin` | `view` lifecycle | 粘贴后滚动到光标 |

**方案**：新建 `src/lib/editor/plugins/editor-props-plugin.ts`，将 5 个插件合并为 1 个 ProseMirror Plugin。ProseMirror 支持在单个 Plugin 中定义多个 props handler（`transformPastedHTML`、`handleClickOn`、`handleKeyDown`、`decorations`）和 `view` lifecycle。

**收益**：减少 4 个插件实例，每次事务少遍历 4 个 apply() 调用。

### F2: highlight 插件添加 code_block 范围检查

**问题**：`highlight.ts` 的 `apply()` 在每次 doc 变化时都调用 `decorationSet.map(tr.mapping, newState.doc)` 遍历所有 decoration。对于大量代码块的文档，即使编辑发生在普通段落中，decoration mapping 仍需处理所有代码块的 decoration 位置映射。

**方案**：在 `apply()` 中添加短路逻辑 — 如果 transaction 的变更范围未涉及任何 `code_block` 节点，直接返回已 map 的 decorationSet，跳过 debounce timer 的重新调度。

**具体逻辑：**
```typescript
// 检查变更范围是否涉及 code_block
let affectsCodeBlock = false;
tr.mapping.maps.forEach((stepMap) => {
  stepMap.forEach((from, to) => {
    newState.doc.nodesBetween(from, Math.min(to, newState.doc.content.size), (node) => {
      if (node.type.name === 'code_block') affectsCodeBlock = true;
      return !affectsCodeBlock; // 找到即停止
    });
  });
});
if (!affectsCodeBlock) return decorationSet.map(tr.mapping, newState.doc);
```

**收益**：90%+ 的按键输入发生在普通段落，短路后省去 debounce timer 调度和后续的全量 hljs 重高亮。

### F3: 合并 tableKeysPlugin 到 enterHandlerPlugin

**问题**：`tableKeysPlugin` 和 `enterHandlerPlugin` 都在 Enter 键时遍历节点深度。两个插件独立做相似的深度遍历。

**方案**：将 `tableKeysPlugin` 的逻辑（Cmd+Enter 添加行、Shift+Enter 换行）合并到 `enterHandlerPlugin` 的 `handleKeyDown` 中。合并后的 Enter handler 执行单次深度遍历，在同一个 handler 中处理所有 Enter 变体。

**合并后的 Enter 处理逻辑：**
1. 遍历 `$from.depth` 确定当前位置（table cell / list item / 其他）
2. 在 table cell 中：
   - Cmd/Ctrl+Enter → 新增行
   - Shift+Enter → 硬换行
3. 在 list item 中：让 ProseMirror 默认 keymap 处理
4. 在普通段落中：代码块创建 / 表格创建 / splitBlock

**收益**：减少 1 个插件实例 + 消除重复的深度遍历。

## 修改文件清单

### Phase 2 文件

| 文件 | 操作 | 说明 |
|------|------|------|
| `src/lib/editor/plugins/editor-props-plugin.ts` | 新建 | 合并 5 个 prop 插件 |
| `src/lib/editor/setup.ts` | 修改 | 删除 5 个内联插件定义，使用合并后的单一导入；删除 tableKeysPlugin 导入 |
| `src/lib/editor/plugins/highlight.ts` | 修改 | apply() 中添加 code_block 范围检查短路 |
| `src/lib/editor/plugins/enter-handler.ts` | 修改 | 合并 tableKeysPlugin 逻辑 |
| `src/lib/editor/plugins/table-keys.ts` | 删除 | 功能已合并到 enter-handler |

### Phase 3 文件

| 文件 | 操作 | 说明 |
|------|------|------|
| `src/lib/editor/schema.ts` | 新建 | 统一 ProseMirror Schema（23 nodes + 5 marks） |
| `src/lib/editor/markdown.ts` | 新建 | markdown-it 解析器 + MarkdownSerializer |
| `src/lib/editor/commands.ts` | 新建 | 所有编辑器命令（标准 ProseMirror 签名） |
| `src/lib/editor/setup.ts` | 重写 | `MorayaEditor` 接口 + 直接 EditorView 创建 |
| `src/lib/editor/Editor.svelte` | 修改 | ~30 处 `editor.action()` → `editor.view` |
| `src/routes/+page.svelte` | 修改 | `callCommand()` → `commands.ts` 直接调用 |
| `src/lib/editor/plugins/*.ts` | 修改 | 6 个插件去除 `$prose`/`$view` 包装 |
| `src/lib/editor/plugins/definition-list.ts` | 重写 | 仅保留 inputRule，schema 移入 schema.ts |
| `src/lib/editor/plugins/empty-doc-focus.ts` | 删除 | 从未加载 |
| `package.json` | 修改 | 移除 13 个 @milkdown 依赖，新增 15 个 prosemirror-* + markdown-it 依赖 |

## 预期效果

| 指标 | Phase 1 后 | Phase 2 后 | Phase 3 后 |
|------|-----------|-----------|-----------|
| 每次按键序列化 | O(1) dirty 标记 | O(1) | O(1) |
| 插件 apply() 次数 | ~29 | ~24 | ~24（无 Milkdown 包装层开销） |
| Store 通知（每次按键） | 1 个（仅 isDirty） | 同 | 同 |
| highlight apply() 短路 | 无 | 非代码块编辑直接跳过 | 同 |
| Milkdown 抽象层 | 12 个 @milkdown 包 | 同 | **完全移除** |
| editor.action() 间接调用 | ~30+ 处 | 同 | **0（直接 editor.view）** |
| Markdown 解析管线 | remark → MDAST → PM | 同 | **markdown-it → PM（更轻量）** |

## 验证方案

### Phase 2 验证

1. `pnpm check` — 0 TS 错误
2. 在 browser devtools 中验证 `view.state.plugins.length` 减少
3. 在段落中输入（非代码块），验证 highlight apply 被短路（无 300ms debounce 调度）
4. 测试所有合并功能：
   - 粘贴带 `language-xxx` class 的代码块 → 语言正确识别
   - 点击图片 → 光标定位到图片旁（无蓝色全选）
   - Cmd+A → 全选正常
   - 空段落聚焦 → macOS 下假光标显示
   - 长内容粘贴 → 自动滚动到光标位置
5. 表格内快捷键：
   - Cmd+Enter → 新增行
   - Shift+Enter → 硬换行
6. 打开包含代码块的文档，快速输入，观察是否有可感知延迟改善

### Phase 3 验证

1. `pnpm check` — 0 TS 错误 ✅
2. `pnpm build` — 前端编译成功 ✅
3. `grep -r "@milkdown" src/` — 无 @milkdown 引用 ✅
4. 全功能回归测试：
   - 编辑器加载、输入、标题/代码块/表格/数学块渲染
   - 图片操作：插入、拖拽、粘贴、上传、右键菜单、缩放
   - 表格工具栏：增删行列、对齐
   - 搜索替换
   - 大纲面板
   - Task list checkbox 点击
   - 文件切换（syncContent）
   - 源码/分屏模式切换
   - 菜单命令 + 键盘快捷键
   - iPad touch toolbar
