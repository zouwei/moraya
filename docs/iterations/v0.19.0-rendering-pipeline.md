# v0.19.0 — 渲染管线优化（Rendering Pipeline v2）
**版本：** v0.19.0
**状态：** 已完成
**日期：** 2026-03-01

## 概述

针对编辑器与 Typora 的流畅度差距，从渲染管线层面进行系统性优化。核心发现：Moraya 运行在 WKWebView (JavaScriptCore) 上，JS 引擎性能弱于 Electron (V8)，加上 ProseMirror ~29 个插件的同步 apply() 开销，导致每次按键延迟偏高。

## 优化分三个阶段

### Phase 1: 惰性序列化（已完成）

消除 visual 模式下每次按键的全文 markdown 序列化，改为按需序列化。

**改动摘要：**
- `setup.ts`: 新增 `createDirtyTrackPlugin`（O(1) dirty 标记），保留 `createLazyChangePlugin`（500ms debounce，仅 split 模式使用）
- `Editor.svelte`: `onDocChanged` 轻量通知替代 `onChange`，新增 `getFullMarkdown()` 按需序列化
- `editor-store.ts`: 新增 `markDirty()`（仅 false→true 触发通知）和 `scheduleWordCountFromText()`
- `+page.svelte`: `getCurrentContent()` 按需序列化，save/export/AI/guardUnsaved 全部走按需路径
- `AIChatPanel.svelte`: `getDocumentContent` 回调替代静态 prop

### Phase 2: 插件合并与短路优化（已完成）

将 ~29 个插件减少到 ~24 个，并为常见按键添加短路逻辑。

### Phase 3: 去除 Milkdown 抽象层（已完成）

完全移除 Milkdown 抽象层（12 个 `@milkdown/*` 包），改为直接使用 ProseMirror API + prosemirror-markdown + markdown-it。

**核心收益：**
- Bundle 减小（去除 Milkdown core/transformer/utils + remark 生态链）
- 初始化更快（无 Milkdown builder 流程）
- 完全控制渲染管线，消除 `editor.action((ctx) => ctx.get(editorViewCtx))` 间接访问开销（Editor.svelte 中原有 ~30+ 处）
- markdown-it 直接解析比 remark→MDAST→PM 管线更轻量

**改动摘要：**

| 子阶段 | 内容 |
|--------|------|
| 3A | 安装 15 个 prosemirror-* + markdown-it 依赖；新建 `schema.ts`（23 nodes + 5 marks）和 `markdown.ts`（markdown-it 解析器 + MarkdownSerializer） |
| 3B | 新建 `commands.ts`（所有编辑器命令）；6 个插件文件去除 `$prose`/`$view`/`$nodeSchema` 包装 |
| 3C | 完全重写 `setup.ts`：`MorayaEditor` 接口 + 直接 `EditorView` 创建 |
| 3D | 迁移 `Editor.svelte`：~30 处 `editor.action()` → 直接 `editor.view` 访问 |
| 3E | 迁移 `+page.svelte`：`callCommand()` → `commands.ts` 直接调用 |
| 3F | 移除 12 个 `@milkdown/*` 包 + `remark-definition-list`；删除 `empty-doc-focus.ts`；更新 CLAUDE.md |

**新建文件：**

| 文件 | 说明 |
|------|------|
| `src/lib/editor/schema.ts` | 统一 ProseMirror Schema，23 种节点 + 5 种 mark，从 Milkdown 源码精确提取 |
| `src/lib/editor/markdown.ts` | markdown-it 解析器（含 deflist/texmath/table/strikethrough 插件）+ ProseMirror MarkdownSerializer |
| `src/lib/editor/commands.ts` | 所有编辑器命令（标准 ProseMirror `(state, dispatch?, view?) => boolean` 签名） |

**关键抽象替换映射：**

| Milkdown 抽象 | ProseMirror 等价 |
|---|---|
| `$prose(() => new Plugin(...))` | 直接 `new Plugin(...)` / `export function createXxxPlugin(): Plugin` |
| `$view(schema.node, factory)` | `nodeViews: { code_block: factory }` |
| `$nodeSchema('name', () => spec)` | 写入 `schema.ts` |
| `$remark('name', () => plugin)` | `markdown-it-deflist` 替代 |
| `Editor.make().config().use().create()` | `new EditorView(root, { state, nodeViews })` |
| `editor.action((ctx) => ctx.get(editorViewCtx))` | 直接 `editor.view` |
| `callCommand(cmd.key, payload)` | 直接 `cmd(state, dispatch, view)` |
| `getMarkdown(editor)` / `ctx.get(serializerCtx)` | `editor.getMarkdown()` / `serializeMarkdown(doc)` |
| `ctx.get(parserCtx)(md)` | `parseMarkdown(md)` |

**移除的依赖（13 个）：**
`@milkdown/core`, `@milkdown/ctx`, `@milkdown/plugin-clipboard`, `@milkdown/plugin-cursor`, `@milkdown/plugin-history`, `@milkdown/plugin-math`, `@milkdown/plugin-tooltip`, `@milkdown/preset-commonmark`, `@milkdown/preset-gfm`, `@milkdown/prose`, `@milkdown/transformer`, `@milkdown/utils`, `remark-definition-list`

## Phase 2 功能详情

### F1: 合并 5 个 prop 类插件为 1 个

**问题**：`setup.ts` 中定义了 5 个仅使用 `props` 的独立 Plugin，每个都参与事务 apply() 循环。

**5 个待合并插件：**

| 插件 | props 类型 | 功能 |
|------|-----------|------|
| `pasteLanguageFixPlugin` | `transformPastedHTML` | 粘贴时修复 code 块语言属性 |
| `imageClickPlugin` | `handleClickOn` | 图片点击→文本光标（防止蓝色选中） |
| `selectAllFixPlugin` | `handleKeyDown` | macOS Cmd+A 修复 |
| `caretFixPlugin` | `decorations` | WKWebView 空段落假光标 |
| `scrollAfterPastePlugin` | `view` lifecycle | 粘贴后滚动到光标 |

**方案**：新建 `src/lib/editor/plugins/editor-props-plugin.ts`，将 5 个插件合并为 1 个 ProseMirror Plugin。ProseMirror 支持在单个 Plugin 中定义多个 props handler（`transformPastedHTML`、`handleClickOn`、`handleKeyDown`、`decorations`）和 `view` lifecycle。

**收益**：减少 4 个插件实例，每次事务少遍历 4 个 apply() 调用。

### F2: highlight 插件添加 code_block 范围检查

**问题**：`highlight.ts` 的 `apply()` 在每次 doc 变化时都调用 `decorationSet.map(tr.mapping, newState.doc)` 遍历所有 decoration。对于大量代码块的文档，即使编辑发生在普通段落中，decoration mapping 仍需处理所有代码块的 decoration 位置映射。

**方案**：在 `apply()` 中添加短路逻辑 — 如果 transaction 的变更范围未涉及任何 `code_block` 节点，直接返回已 map 的 decorationSet，跳过 debounce timer 的重新调度。

**具体逻辑：**
```typescript
// 检查变更范围是否涉及 code_block
let affectsCodeBlock = false;
tr.mapping.maps.forEach((stepMap) => {
  stepMap.forEach((from, to) => {
    newState.doc.nodesBetween(from, Math.min(to, newState.doc.content.size), (node) => {
      if (node.type.name === 'code_block') affectsCodeBlock = true;
      return !affectsCodeBlock; // 找到即停止
    });
  });
});
if (!affectsCodeBlock) return decorationSet.map(tr.mapping, newState.doc);
```

**收益**：90%+ 的按键输入发生在普通段落，短路后省去 debounce timer 调度和后续的全量 hljs 重高亮。

### F3: 合并 tableKeysPlugin 到 enterHandlerPlugin

**问题**：`tableKeysPlugin` 和 `enterHandlerPlugin` 都在 Enter 键时遍历节点深度。两个插件独立做相似的深度遍历。

**方案**：将 `tableKeysPlugin` 的逻辑（Cmd+Enter 添加行、Shift+Enter 换行）合并到 `enterHandlerPlugin` 的 `handleKeyDown` 中。合并后的 Enter handler 执行单次深度遍历，在同一个 handler 中处理所有 Enter 变体。

**合并后的 Enter 处理逻辑：**
1. 遍历 `$from.depth` 确定当前位置（table cell / list item / 其他）
2. 在 table cell 中：
   - Cmd/Ctrl+Enter → 新增行
   - Shift+Enter → 硬换行
3. 在 list item 中：让 ProseMirror 默认 keymap 处理
4. 在普通段落中：代码块创建 / 表格创建 / splitBlock

**收益**：减少 1 个插件实例 + 消除重复的深度遍历。

## 修改文件清单

### Phase 2 文件

| 文件 | 操作 | 说明 |
|------|------|------|
| `src/lib/editor/plugins/editor-props-plugin.ts` | 新建 | 合并 5 个 prop 插件 |
| `src/lib/editor/setup.ts` | 修改 | 删除 5 个内联插件定义，使用合并后的单一导入；删除 tableKeysPlugin 导入 |
| `src/lib/editor/plugins/highlight.ts` | 修改 | apply() 中添加 code_block 范围检查短路 |
| `src/lib/editor/plugins/enter-handler.ts` | 修改 | 合并 tableKeysPlugin 逻辑 |
| `src/lib/editor/plugins/table-keys.ts` | 删除 | 功能已合并到 enter-handler |

### Phase 3 文件

| 文件 | 操作 | 说明 |
|------|------|------|
| `src/lib/editor/schema.ts` | 新建 | 统一 ProseMirror Schema（23 nodes + 5 marks） |
| `src/lib/editor/markdown.ts` | 新建 | markdown-it 解析器 + MarkdownSerializer |
| `src/lib/editor/commands.ts` | 新建 | 所有编辑器命令（标准 ProseMirror 签名） |
| `src/lib/editor/setup.ts` | 重写 | `MorayaEditor` 接口 + 直接 EditorView 创建 |
| `src/lib/editor/Editor.svelte` | 修改 | ~30 处 `editor.action()` → `editor.view` |
| `src/routes/+page.svelte` | 修改 | `callCommand()` → `commands.ts` 直接调用 |
| `src/lib/editor/plugins/*.ts` | 修改 | 6 个插件去除 `$prose`/`$view` 包装 |
| `src/lib/editor/plugins/definition-list.ts` | 重写 | 仅保留 inputRule，schema 移入 schema.ts |
| `src/lib/editor/plugins/empty-doc-focus.ts` | 删除 | 从未加载 |
| `package.json` | 修改 | 移除 13 个 @milkdown 依赖，新增 15 个 prosemirror-* + markdown-it 依赖 |

## Phase 4: 多窗口体验优化

### F1: Dock 菜单动态文档列表（macOS）

**问题**：右键 Dock 图标只有 "New Window"，无法看到当前打开的文档或切换窗口。

**方案**：

菜单结构：
```
┌─────────────────────────┐
│ New Window              │
├─────────────────────────┤
│ ✓ README.md             │  ← 当前焦点窗口（checkmark）
│   design-notes.md       │
│   Untitled              │  ← 未保存文档
└─────────────────────────┘
```

**改动摘要：**

| 子项 | 内容 |
|------|------|
| 状态跟踪 | `DockDocumentTracker(Mutex<HashMap<String, DockDocEntry>>)` 跟踪窗口↔文件映射 |
| 焦点跟踪 | `FOCUSED_WINDOW_LABEL: Mutex<Option<String>>` 通过 `WindowEvent::Focused` 更新 |
| Tauri 命令 | `register_dock_document(display_name, file_path)` — 前端文件变化时调用 |
| 菜单构建 | `refresh_dock_menu()` — 重建 NSMenu 并 `setDockMenu:`，通过 `run_on_main_thread` 确保线程安全 |
| 点击处理 | `focusWindowAction:` — 通过 `NSMenuItem.representedObject` 获取窗口 label，调用 `window.set_focus()` |
| 自动清理 | `WindowEvent::Destroyed` 自动从 tracker 移除条目 |
| 前端注册 | `editorStore.subscribe` 中检测 `currentFilePath` 变化时 `invoke('register_dock_document')` |

### F2: 新窗口级联定位

**问题**：所有新窗口都 `.center()` 到屏幕正中，完全重叠，看起来像"覆盖"了原文档。

**方案**：新窗口从现有窗口位置偏移 +30px 创建，无现有窗口时回退到居中。

### F3: 跨窗口视图设置同步

**问题**：多窗口间 sidebar/outline 显示状态不一致。

**方案**：通过 Tauri `emit`/`listen` 事件实时同步 `showSidebar` 和 `showOutline` 设置，使用 `syncGuard` + 源窗口 label 防止回环广播。

### Phase 4 修改文件清单

| 文件 | 操作 | 说明 |
|------|------|------|
| `src-tauri/src/lib.rs` | 修改 | DockDocumentTracker + FOCUSED_WINDOW_LABEL + register_dock_document 命令 + WindowEvent 处理 |
| `src-tauri/src/dock.rs` | 重写 | 动态 NSMenu 构建 + focusWindowAction: + refresh_dock_menu() + nsstring() helper |
| `src/routes/+page.svelte` | 修改 | editorStore subscriber 中调用 register_dock_document |
| `src/lib/stores/settings-store.ts` | 修改 | 跨窗口 emit/listen 视图设置同步 |

## 预期效果

| 指标 | Phase 1 后 | Phase 2 后 | Phase 3 后 | Phase 5 后 |
|------|-----------|-----------|-----------|-----------|
| 每次按键序列化 | O(1) dirty 标记 | O(1) | O(1) | 同 |
| 插件 apply() 次数 | ~29 | ~24 | ~24（无 Milkdown 包装层开销） | 同 |
| Store 通知（每次按键） | 1 个（仅 isDirty） | 同 | 同 | 同 |
| highlight apply() 短路 | 无 | 非代码块编辑直接跳过 | 同 | 同 |
| Milkdown 抽象层 | 12 个 @milkdown 包 | 同 | **完全移除** | 同 |
| editor.action() 间接调用 | ~30+ 处 | 同 | **0（直接 editor.view）** | 同 |
| Markdown 解析管线 | remark → MDAST → PM | 同 | **markdown-it → PM（更轻量）** | 同 |
| 文件切换 parseMarkdown | 每次全量解析 | 同 | 同 | **LRU 缓存命中 ~0ms** |
| 文件切换 hljs 高亮 | N × hljs.highlight() | 同 | 同 | **N × Map.get()** |
| 大文件解析阻塞 | 同步阻塞 | 同 | 同 | **≥50KB 异步 yield** |
| 连续快速切换 | 全部执行 | 同 | 同 | **只渲染最后一个** |

## 验证方案

### Phase 2 验证

1. `pnpm check` — 0 TS 错误
2. 在 browser devtools 中验证 `view.state.plugins.length` 减少
3. 在段落中输入（非代码块），验证 highlight apply 被短路（无 300ms debounce 调度）
4. 测试所有合并功能：
   - 粘贴带 `language-xxx` class 的代码块 → 语言正确识别
   - 点击图片 → 光标定位到图片旁（无蓝色全选）
   - Cmd+A → 全选正常
   - 空段落聚焦 → macOS 下假光标显示
   - 长内容粘贴 → 自动滚动到光标位置
5. 表格内快捷键：
   - Cmd+Enter → 新增行
   - Shift+Enter → 硬换行
6. 打开包含代码块的文档，快速输入，观察是否有可感知延迟改善

### Phase 3 验证

1. `pnpm check` — 0 TS 错误 ✅
2. `pnpm build` — 前端编译成功 ✅
3. `grep -r "@milkdown" src/` — 无 @milkdown 引用 ✅
4. 全功能回归测试：
   - 编辑器加载、输入、标题/代码块/表格/数学块渲染
   - 图片操作：插入、拖拽、粘贴、上传、右键菜单、缩放
   - 表格工具栏：增删行列、对齐
   - 搜索替换
   - 大纲面板
   - Task list checkbox 点击
   - 文件切换（syncContent）
   - 源码/分屏模式切换
   - 菜单命令 + 键盘快捷键
   - iPad touch toolbar

### Phase 4 验证

1. `cargo check` + `pnpm check` — 0 错误
2. macOS Dock 右键菜单：
   - 显示 "New Window" + 当前文档列表
   - 焦点窗口有 checkmark
   - 点击文档名切换窗口
   - 关闭窗口后自动从列表移除
   - 未保存文档显示 "Untitled" / "未命名"
   - Save As 后文件名实时更新
3. 新窗口不再完全重叠（级联偏移 30px）
4. 多窗口 sidebar/outline 状态同步

## Phase 5: 文件切换性能优化

### 概述

编辑器在可视化模式切换文档时，每次都重新解析 markdown（~5-10ms/10KB），高亮插件全量重跑 hljs，无任何缓存。连续快速切换多个文件时，中间文件的解析和渲染全部浪费。从四个方向优化文件切换性能。

### F5.1: ProseMirror Doc LRU 缓存（优化 A）

**问题**：每次切回已打开的文档都要重新 `parseMarkdown()`，浪费 CPU。

**方案**：新建 `src/lib/editor/doc-cache.ts`，基于 Map 的 LRU 缓存，最多 10 条目。

- 缓存键：`filePath + ":" + DJB2_hash(markdown)`
- `get(filePath, md)`: 命中时 delete + re-insert 移到末尾
- `set(filePath, md, doc)`: 满时删 `Map.keys().next()` 最旧条目
- `invalidate(filePath)`: 删该路径所有条目（save 后调用）
- 导出 `docCache` 单例 + `invalidateDocCache()` + `clearDocCache()`

**集成点**：
- `Editor.svelte` `syncContent()`: 解析前查缓存 → 命中则跳过 parse
- `Editor.svelte` `applySyncToEditor()`: 同上
- `file-service.ts` `saveFile()` / `saveFileAs()`: 保存后调用 `invalidateDocCache()`

**收益**：切回已打开文档时从 ~5-10ms 降到 ~0ms（Map.get）。

### F5.2: 高亮装饰 per-block hljs 缓存（优化 B）

**问题**：`getDecorations(doc)` 对每个 code_block 都调用 `hljs.highlight()`，即使代码内容未变。

**方案**：模块级 `hljsCache: Map<string, CachedSpan[]>`，最多 100 条目，FIFO 淘汰。

- 键：`language + "\0" + codeText`
- 值：`{ relOffset, length, classes }[]`（相对偏移量，与 block 位置无关）
- 命中缓存时，用 `cachedSpans + blockStart` 偏移生成 Decoration
- 未命中时，运行 hljs → flattenHljsTree → 存缓存 + 生成 Decoration

**收益**：file-switch 时从 N × hljs 调用降为 N × Map.get()。编辑时仅修改的块重新高亮。

### F5.3: 大文件异步解析（优化 C）

**问题**：大文件（≥50KB）的 `parseMarkdown()` 可能阻塞主线程导致 UI 卡顿。

**技术评估**：
- Web Worker 需解决 schema.ts 引入 katex（使用 `document`）的问题，复杂度高
- 对典型文件（5-10ms），Worker 的 `postMessage` + `toJSON/fromJSON` 开销可能更大
- 采用 `setTimeout(0)` yield 方案：简单务实，让大文件解析让出事件循环

**方案**：`markdown.ts` 新增 `parseMarkdownAsync()`：
```typescript
const ASYNC_PARSE_THRESHOLD = 50_000;
export function parseMarkdownAsync(markdown: string): Promise<PmNode> {
  if (markdown.length < ASYNC_PARSE_THRESHOLD) {
    return Promise.resolve(parseMarkdown(markdown));
  }
  return new Promise(resolve => setTimeout(() => resolve(parseMarkdown(markdown)), 0));
}
```

**集成**：`syncContent()` 中大文件走 async 路径 + generation 守卫。

### F5.4: 连续快速切换取消机制（优化 D）

**问题**：连续点击多个文件时，中间文件的解析和渲染全部执行完毕后才显示最终文件。

**方案**：

**Editor.svelte** — `syncGeneration` 计数器：
- `syncContent()` 开头：`const myGen = ++syncGeneration`
- 大文件异步回调前检查 `if (myGen !== syncGeneration) return`

**+page.svelte** — `replaceContentAndScrollToTop()` 中捕获 `fileSelectSerial`：
- `syncVisualEditor()` 后检查 `if (mySerial !== fileSelectSerial) return`
- `scrollEditorToTop()` 前检查 `if (mySerial !== fileSelectSerial) return`

**收益**：连续点击 5 个文件，只有最后一个完成完整渲染管线。

### F5.5: syncContent 重构

将 syncContent 的两步同步逻辑提取为 `applySyncDoc()` 辅助函数：
- Step 1: `view.dispatch(tr)` + `addToHistory:false` + `file-switch` meta
- Step 2: `EditorState.create()` + `view.updateState()`
- 搜索清理 + `cachedSelFrom` 重置 + `scheduleExtractHeadings()`

三种路径共享此函数：
1. 缓存命中 → 同步快路径
2. 小文件未命中 → 同步 `parseMarkdown()`
3. 大文件未命中 → `parseMarkdownAsync()` + generation 守卫

### Phase 5 修改文件清单

| 文件 | 优化项 | 操作 |
|------|--------|------|
| `src/lib/editor/doc-cache.ts` | A | 新建 — LRU 缓存类 |
| `src/lib/editor/Editor.svelte` | A+C+D | 修改 — syncContent 集成缓存+异步+generation 守卫；提取 applySyncDoc()；applySyncToEditor 加缓存 |
| `src/lib/editor/plugins/highlight.ts` | B | 修改 — hljsCache + 重构 getDecorations() |
| `src/lib/editor/markdown.ts` | C | 修改 — 新增 parseMarkdownAsync() |
| `src/lib/services/file-service.ts` | A | 修改 — save 后 invalidateDocCache |
| `src/routes/+page.svelte` | D | 修改 — replaceContentAndScrollToTop 加 serial 守卫 |

### Phase 5 验证

1. `pnpm check` — 0 错误
2. 文件 A → B → 回 A，第二次跳过 parseMarkdown（缓存命中）
3. 编辑 A → 保存 → 关闭 → 重开，缓存失效后重新解析
4. 连续打开 11+ 文件，第 1 个被 LRU 淘汰
5. 含 code_block 文件切走切回，getDecorations 命中 hljs 缓存
6. 编辑某 code_block，该块重新高亮，其他块用缓存
7. 快速连续点 5+ 文件，只有最后一个完整渲染
8. 100KB+ 文件，UI 不卡顿
